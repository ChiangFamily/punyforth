.set CELLS,4
.set link,0
.set STATE_COMPILE,1
.set STATE_INTERPRET,0
.set IMMEDIATE,-1
.set TRUE,-1
.set FALSE,0

.data

STACK_ORIG:   .int 0
var0:         .int 0
state_var:    .int STATE_INTERPRET
LAST_WORD:    .int FINAL_WORD
input_index:  .int 0
input_buffer:

.ascii ": FALSE 0 ; : TRUE -1 ; : 0= 0 = ; : 1+ 1 + ; : 1- 1 - ;"              ,"\n"
.ascii ": % /mod drop ; : / /mod nip ;"                                        ,"\n"
.ascii ": '.' [ char . ] literal ; : '\"' [ char \" ] literal ;"               ,"\n"    
.ascii ": 'F' [ char F ] literal ; : ')' [ char ) ] literal ;"                 ,"\n"    
.ascii ": cr 10 emit ; : space 32 emit ; "                                     ,"\n"    
.ascii ": [compile] word find drop , ; immediate"                              ,"\n"    

.ascii ": if"                                                                  ,"\n"
.ascii "       compile_time_only"                                              ,"\n"
.ascii "       lit branch0 ,"                                                  ,"\n"
.ascii "       here >r"                                                        ,"\n"
.ascii "       0 ,"                                                            ,"\n"
.ascii "       rswap ; immediate"                                              ,"\n"
.ascii ": else"                                                                ,"\n"
.ascii "       compile_time_only"                                              ,"\n"
.ascii "       rswap"                                                          ,"\n"
.ascii "       lit branch , here >r , 0 ,"                                     ,"\n"
.ascii "       rswap"                                                          ,"\n"
.ascii "       r> dup"                                                         ,"\n"
.ascii "       here swap - 1 cells -"                                          ,"\n"
.ascii "       swap !"                                                         ,"\n"
.ascii "       rswap ; immediate"                                              ,"\n"                                
.ascii ": then"                                                                ,"\n"
.ascii "       compile_time_only"                                              ,"\n"
.ascii "       rswap"                                                          ,"\n"
.ascii "       r> dup"                                                         ,"\n"
.ascii "       here swap - 1 cells -"                                          ,"\n"
.ascii "       swap ! ; immediate"                                             ,"\n"
.ascii ": ."                                                                   ,"\n"
.ascii "       dup 0 < if 45 emit -1 * then"                                   ,"\n"        
.ascii "       10 /mod dup 0= if"                                              ,"\n"    
.ascii "           drop 48 + emit"                                             ,"\n"            
.ascii "       else"                                                           ,"\n"        
.ascii "          . 48 + emit"                                                 ,"\n"            
.ascii "       then ;"                                                         ,"\n"            

.ascii ": ? @ . ;"                                                             ,"\n"                    

.ascii ": do"                                                                  ,"\n"
.ascii "       compile_time_only"                                              ,"\n"
.ascii "       lit >r , lit >r , lit rswap ,"                                  ,"\n"
.ascii "       here >r rswap"                                                  ,"\n"
.ascii "   ; immediate"                                                        ,"\n"    
.ascii ": loop"                                                                ,"\n"
.ascii "       compile_time_only"                                              ,"\n"
.ascii "       lit r> , lit 1+ , lit >r ,"                                     ,"\n"
.ascii "       lit r2dup , lit r> , lit r> ,"                                  ,"\n"
.ascii "       lit < , lit invert , lit branch0 ,"                             ,"\n"
.ascii "       rswap r> here - 1 cells - ,"                                    ,"\n"
.ascii "       lit r> , lit r> , lit drop , lit drop ,"                        ,"\n"        
.ascii "   ; immediate"                                                        ,"\n"            

.ascii ": begin"                                                               ,"\n"
.ascii "       compile_time_only"                                              ,"\n"
.ascii "       here >r rswap ; immediate"                                      ,"\n"
.ascii ""                                                                      ,"\n"
.ascii ": again"                                                               ,"\n"
.ascii "       compile_time_only"                                              ,"\n"
.ascii "       lit branch ,"                                                   ,"\n"
.ascii "       rswap r> here - 1 cells - , ; immediate"                        ,"\n"
.ascii ""                                                                      ,"\n"
.ascii ": until"                                                               ,"\n"
.ascii "       compile_time_only"                                              ,"\n"
.ascii "       lit branch0 ,"                                                  ,"\n"
.ascii "       rswap r> here - 1 cells - , ; immediate"                        ,"\n"

.ascii ": ( begin key ')' = until ; immediate"                                 ,"\n"

.ascii ": s\""                                                                 ,"\n"
.ascii "    compile_time_only"                                                 ,"\n"
.ascii "    lit litstring ,"                                                   ,"\n"
.ascii "    here                    ( length will be placed here )"            ,"\n"
.ascii "    0 ,                     ( put a dummy length )"                    ,"\n"
.ascii "    0                       ( length counter )"                        ,"\n"
.ascii "    key dup '\"' <> if"                                                ,"\n"
.ascii "        begin"                                                         ,"\n"
.ascii "            swap 1+ swap    ( increase length )"                       ,"\n"
.ascii "            c,              ( store character as byte )"               ,"\n"  
.ascii "        key dup '\"' = until"                                          ,"\n"
.ascii "    then"                                                              ,"\n"
.ascii "    drop"                                                              ,"\n"
.ascii "    swap !  ( overwrite dummy length with the calculated one )"        ,"\n"
.ascii " ; immediate"                                                          ,"\n"

.ascii ": abs ( n -- |n| ) dup 0 < if -1 * then ;"                             ,"\n"
.ascii ": max ( a b -- max ) 2dup < if nip else drop then ;"                   ,"\n"
.ascii ": min ( a b -- min ) 2dup < if drop else nip then ;"                   ,"\n"

.ascii ": .\""                                                                 ,"\n"
.ascii "    state @ 0= if            ( interpretation mode )"                  ,"\n"
.ascii "        begin"                                                         ,"\n"
.ascii "            key dup 34 = if"                                           ,"\n"
.ascii "                drop exit"                                             ,"\n"
.ascii "            then"                                                      ,"\n"
.ascii "            emit"                                                      ,"\n"
.ascii "        again"                                                         ,"\n"
.ascii "    else                     ( compilation mode )"                     ,"\n"
.ascii "        [compile] s\" lit type ,"                                                ,"\n"
.ascii "    then ; immediate"                                                  ,"\n"
.ascii ": .s depth 0 do . cr loop ;"                                           ,"\n"

.ascii ": factorial ( n -- n! )"                                               ,"\n"
.ascii "       dup 0= if"                                                      ,"\n"
.ascii "           drop 1"                                                     ,"\n"
.ascii "       else"                                                           ,"\n"
.ascii "           dup 1 = if"                                                 ,"\n"
.ascii "               drop 1"                                                 ,"\n"
.ascii "           else"                                                       ,"\n"
.ascii "               dup 1- factorial *"                                     ,"\n"
.ascii "           then"                                                       ,"\n"
.ascii "       then ;"                                                         ,"\n"

.ascii "variable test_count"                                                   ,"\n"
.ascii ": assert ( bool -- )"                                                  ,"\n"
.ascii "       test_count @ 1+ test_count ! '.' emit"                          ,"\n"
.ascii "       TRUE <> if 'F' emit test_count ? then ;"                        ,"\n"
.ascii ": selftest ( -- )"                                                     ,"\n"
.ascii "   .\" testing\""                                                     ,"\n"
.ascii "   0 test_count !"                                                     ,"\n"
.ascii "   12 3 min 3 = assert"                                                ,"\n"
.ascii "   -3 7 min -3 = assert"                                               ,"\n"
.ascii "   -3 -7 min -7 = assert"                                              ,"\n"
.ascii "   132 33 max 132 = assert"                                            ,"\n"
.ascii "   -33 77 max 77 = assert"                                             ,"\n"
.ascii "   -389 -27 max -27 = assert"                                          ,"\n"
.ascii "   0 1- -1 = assert"                                                   ,"\n"
.ascii "   -10 1+ -9 = assert"                                                 ,"\n"
.ascii "   -10 4 < assert"                                                     ,"\n"
.ascii "   -10 -4 < assert"                                                    ,"\n"
.ascii "   324 12 > assert"                                                    ,"\n"
.ascii "   -24 -212 > assert"                                                  ,"\n"
.ascii "   24 -2 > assert"                                                     ,"\n"
.ascii "   -12 2 / 6 + 0 = assert"                                             ,"\n"
.ascii "   -123 abs 123 = assert 32 abs 32 = assert 0 abs 0 = assert"          ,"\n"
.ascii "   -42 abs 42 abs = assert"                                            ,"\n"
.ascii "   -12 -3 * 36 = assert -3 4 * -12 = assert 2 -4 * -8 = assert"        ,"\n"
.ascii "   -12 -3 + -15 = assert -3 4 + 1 = assert 2 -4 + -2 = assert"         ,"\n"
.ascii "   -12 -3 - -9 = assert -3 4 - -7 = assert 2 -4 - 6 = assert"          ,"\n"
.ascii "   12 -6 / -2 = assert -36 6 / -6 = assert -4 -2 / 2 = assert "        ,"\n"
.ascii "   4 4 >= assert 5 4 >= assert -4 -10 >= assert 4 5 >= invert assert"  ,"\n"
.ascii "   6 6 <= assert 3 9 <= assert -9 -5 <= assert 10 2 <= invert assert"  ,"\n"        
.ascii "   12 3 /mod 4 = assert 0 = assert 12 4 / 3 = assert"                  ,"\n"
.ascii "   13 5 /mod 2 = assert 3 = assert 14 6 % 2 = assert"                  ,"\n"
.ascii "   TRUE if TRUE assert else FALSE assert then"                         ,"\n"
.ascii "   FALSE if FALSE assert else TRUE assert then"                        ,"\n"
.ascii "   2 TRUE if dup * then 4 = assert"                                    ,"\n"
.ascii "   2 FALSE if dup * then 2 = assert"                                   ,"\n"                
.ascii "   0 11 1 do i + loop 55 = assert"                                     ,"\n"            
.ascii "   0 8 2 do 9 3 do i j + + loop loop 360 = assert"                     ,"\n"                
.ascii "   9 factorial 362880 = assert"                                        ,"\n"                      
.ascii "   2 10 begin 1- swap 2 * swap dup 0= until drop 2048 = assert"        ,"\n"
.ascii "   1 0 or 1 = assert 0 1 or 1 = assert"                                ,"\n"    
.ascii "   1 1 or 1 = assert 0 0 or 0 = assert"                                ,"\n"
.ascii "   1 0 and 0 = assert 0 1 and 0 = assert"                              ,"\n"    
.ascii "   1 1 and 1 = assert 0 0 and 0 = assert"                              ,"\n"
.ascii "   1 0 xor 1 = assert 0 1 xor 1 = assert"                              ,"\n"    
.ascii "   1 1 xor 0 = assert 0 0 xor 0 = assert"                              ,"\n"        
.ascii "   10 2 < 3 1 > or if 1 else 0 then 1 = assert"                        ,"\n"
.ascii "   3 10 < 3 11 > and if 1 else 0 then 0 = assert"                      ,"\n"
.ascii "   -98 45 < 33 11 > and if 1 else 0 then 1 = assert"                   ,"\n"        
.ascii ";"                                                                     ,"\n"            
.ascii "selftest test_count ? .\"  OK\" cr"                                      ,"\n"    
// TODO does>, exceptionok, stack underflow, ?-nel ne lepjen ki a repl
input_size:  .int . - input_buffer
here_var:    .int 0
dictionary:  .space 8192
rstack:      .space 256
prompt_str:  .ascii "\n % " 
